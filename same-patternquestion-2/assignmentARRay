1st-questionGiven a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.

A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).

 

Example 1:

Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]
Explanation: The array ans is built as follows: 
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
Example 2:

Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]
Explanation: The array ans is built as follows:
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
 
 
 
    solution
     in js by me
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var buildArray = function(nums) {
    let ans=[];
  for (let i=0;i<nums.length;i++){
     // let store= nums[i];
      ans.push(nums[nums[i]]);
  }
  return ans;
  };

in java not by me
class Solution {
    public int[] buildArray(int[] nums) {
        int[] arr = new int[nums.length];
        for(int i=0;i<nums.length;i++) arr[i]=nums[nums[i]]; 
        return arr;
    }
}






2nd qusetion

 Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).

Specifically, ans is the concatenation of two nums arrays.

Return the array ans.

 
ans:-
Example 1:

Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]




/**
 * @param {number[]} nums
 * @return {number[]}
 */
var getConcatenation = function(nums) {
    /*
        let ans=[];
        ans=[...nums,...nums]
        return ans;
    */
    
    //2nd way but not recommended
    let ans =[];
    for(let i=0;i<nums.length;i++){
        ans.push(nums[i])
    }
    for(let i=0;i<nums.length;i++){
        ans.push(nums[i])
    }
    return ans;
    };
    //3rd but logic is not mine 
    

let ans =[];

for(let i=0;i<nums.length;i++){
   ans[i] =nums[i]
 ans[nums.length+i] = nums[i]
}
return ans;


in java not by me 
class Solution {
    public int[] getConcatenation(int[] nums) {
        int len = nums.length;
        int[] ans = new int[len*2];
        for(int i = 0; i < len; i++){
            ans[i] = nums[i];
            ans[i+len] = nums[i];
        }
     
        return ans;
    }
}
//simply use this 
/*arr[i] = nums[i]; // Copy the element from nums to the first half of arr
arr[nums.length + i] = nums[i];  // Copy the same element to the second half of arr
*/ 





Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).

Return the running sum of nums.

 

Example 1:

Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].


/**
 * @param {number[]} nums
 * @return {number[]}
 */
var runningSum = function(nums) {
    let c=0;
  //  let array=[];
    for(let i=0;i<nums.length;i++){
        let a =nums[i];
        c=c+a;
     //   array.push(c)
         nums[i]=c
    }
   // nums=array;
    return nums
};

You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has.

A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.

 

Example 1:

Input: accounts = [[1,2,3],[3,2,1]]
Output: 6
Explanation:
1st customer has wealth = 1 + 2 + 3 = 6
2nd customer has wealth = 3 + 2 + 1 = 6
Both customers are considered the richest with a wealth of 6 each, so return 6.

/**
 * @param {number[][]} accounts
 * @return {number}
 */
var maximumWealth = function(accounts) {
    //  return Math.max(...accounts.map(customer => customer.reduce((acc, curr) => acc + curr, 0)));
    return Math.max(...accounts.map(item=>item.reduce((acc,cul)=>acc+cul,0)))
  };
  
  